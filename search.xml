<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bfs</title>
    <url>/yzhiwei.github.io/2019/04/21/bfs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><h2 id="实现的思想"><a href="#实现的思想" class="headerlink" title="实现的思想"></a>实现的思想</h2><p>对于bfs，我们需要的就是按层次依次遍历，需要采用队列这一个数据结构，当然，我们也可以采用模拟队列的方式来操作，我们首先要做的就是将起始点的“朋友”加入队列，然后在加入“朋友”的“朋友”</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//队列的建立</span></span><br><span class="line"><span class="keyword">int</span> start, ed <span class="comment">//起始点和终止点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q.push(start); 先将start入队</span><br><span class="line">	q cur,next; <span class="comment">//next为cur的下一个元素</span></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">    	cur=q.front();</span><br><span class="line">    	q.pop();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		next=cur+  ;</span><br><span class="line">    		<span class="keyword">if</span>(     )</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">if</span>(到达终点)</span><br><span class="line">    			&#123;</span><br><span class="line"></span><br><span class="line">    			&#125;</span><br><span class="line">    		q.push(next);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">q.pop();</span><br></pre></td></tr></table></figure>
<p>对于有些题目，必须要清空队列，但有些不清空队列也能ac，奇怪。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>bfs一般是用来求最短路径的，我们一般都会申请一个数组，来记录到达其中一点的最短路径</p>
<p>有时我们需要输出路径，这时候我们需要新建一个数组，来储存它上一个节点的信息</p>
<h2 id="一个完整题的代码"><a href="#一个完整题的代码" class="headerlink" title="一个完整题的代码"></a>一个完整题的代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 31</span></span><br><span class="line"><span class="keyword">char</span> a[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">6</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;<span class="comment">//2向右3向左4向上</span></span><br><span class="line"><span class="keyword">int</span> L,R,C;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line">node start,ed;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; Q;</span><br><span class="line">    Q.push(start);</span><br><span class="line">    node cur;</span><br><span class="line">     node next;</span><br><span class="line">    <span class="keyword">while</span>(Q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        cur=Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                next.x=cur.x+dir[i][<span class="number">0</span>];</span><br><span class="line">                next.y=cur.y+dir[i][<span class="number">1</span>];</span><br><span class="line">                next.z=cur.z+dir[i][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(next.x&gt;=<span class="number">0</span>&amp;&amp;next.x&lt;R&amp;&amp;next.y&gt;=<span class="number">0</span>&amp;&amp;next.y&lt;C&amp;&amp;next.z&gt;=<span class="number">0</span>&amp;&amp;next.z&lt;L&amp;&amp;a[next.z][next.x][next.y]!=<span class="string">'#'</span>&amp;&amp;d[next.z][next.x][next.y]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//a[cur.z][cur.x][cur.y]='#';  这样操作的话在栈中的点，也有可能到达当前的next点，</span></span><br><span class="line">                    <span class="comment">//若用d[next.z][next.x][next.y]==0判断，只要到达next，就不会再判断</span></span><br><span class="line">                    d[next.z][next.x][next.y]=d[cur.z][cur.x][cur.y]+<span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">if</span>(next.x==ed.x&amp;&amp;next.y==ed.y&amp;&amp;next.z==ed.z)</span><br><span class="line">                          <span class="keyword">return</span> d[ed.z][ed.x][ed.y];</span><br><span class="line">                     Q.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;L&gt;&gt;R&gt;&gt;C&amp;&amp;(L+R+C)!=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       sum=<span class="number">0</span>;</span><br><span class="line">       <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L;i++)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;R;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;C;k++)</span><br><span class="line">          &#123;</span><br><span class="line"> </span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;a[i][j][k];</span><br><span class="line">           <span class="keyword">if</span>(a[i][j][k]==<span class="string">'S'</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               start.z=i;start.x=j;start.y=k;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(a[i][j][k]==<span class="string">'E'</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               ed.z=i;ed.x=j;ed.y=k;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">// cout&lt;&lt;start.x&lt;&lt; " "&lt;&lt;start.y&lt;&lt;" "&lt;&lt;start.z&lt;&lt;endl;</span></span><br><span class="line">      <span class="comment">// cout&lt;&lt;ed.x&lt;&lt;" "&lt;&lt;ed.y&lt;&lt;" "&lt;&lt;ed.z&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">if</span>( bfs()==<span class="number">-1</span>)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"Trapped!\n"</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Escaped in %d minute(s).\n"</span>,d[ed.z][ed.x][ed.y]);</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/yzhiwei.github.io/2019/01/23/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>latex公式总结</title>
    <url>/yzhiwei.github.io/2019/07/22/%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="上下标，分数和根号"><a href="#上下标，分数和根号" class="headerlink" title="上下标，分数和根号"></a>上下标，分数和根号</h1><p>下标<code>_</code>  <script type="math/tex">X_2</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$X_2$$</span><br></pre></td></tr></table></figure></p>
<p>上标<code>^</code>  <script type="math/tex">X^2</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$X^2$$</span><br></pre></td></tr></table></figure></p>
<p>混合使用  <script type="math/tex">x^2_5</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$x^2_5$$</span><br></pre></td></tr></table></figure></p>
<p>分数<code>frac</code>  <script type="math/tex">\frac{3}{5}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\frac&#123;3&#125;&#123;5&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>根号 <code>sqrt</code> <script type="math/tex">\sqrt[4]{5}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\sqrt[4]&#123;5&#125;$$</span><br></pre></td></tr></table></figure></p>
<h1 id="常用的运算符"><a href="#常用的运算符" class="headerlink" title="常用的运算符"></a>常用的运算符</h1><p>加减<code>\pm</code>  <script type="math/tex">{x}\pm{y}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$&#123;x&#125;\pm&#123;y&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>乘 <code>\times</code> <script type="math/tex">{x}\times{y}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$&#123;x&#125;\times&#123;y&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>除 <code>\div</code>   <script type="math/tex">{x}\div{y}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$&#123;x&#125;\div&#123;y&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>点乘 <code>\cdot</code> <script type="math/tex">{x}\cdot{y}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$&#123;x&#125;\cdot&#123;y&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>大于等于 <code>\geq</code> <script type="math/tex">{x}\geq{y}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$&#123;x&#125;\geq&#123;y&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>小于等于 <code>\leq</code> <script type="math/tex">{x}\leq{y}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$&#123;x&#125;\leq&#123;y&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>不等于 <code>\neq</code> <script type="math/tex">{x}\neq{y}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$&#123;x&#125;\neq&#123;y&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>约等于 <code>\approx</code> <script type="math/tex">{x}\approx{y}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$&#123;x&#125;\approx&#123;y&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>恒等于 <code>\equiv</code>  <script type="math/tex">{x}\equiv{y}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$&#123;x&#125;\equiv&#123;y&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>累加 <code>\sum</code> <script type="math/tex">\sum_{i=0}^{n}{(x_i+y_i)}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\sum_&#123;i=0&#125;^&#123;n&#125;&#123;(x_i+y_i)&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>累乘 <code>\prod</code> <script type="math/tex">\prod_{i=1}^{n}{x_i}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\prod_&#123;i=1&#125;^&#123;n&#125;&#123;x_i&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>求极限 <code>\lim</code> <script type="math/tex">\lim_{x\to0}{x}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\lim_&#123;x\to0&#125;&#123;x&#125;$$</span><br></pre></td></tr></table></figure></p>
<p>求积分 <code>\int</code> <script type="math/tex">\int_{a}^{b}{f(x)}</script><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\int_&#123;a&#125;^&#123;b&#125;&#123;f(x)&#125;$$</span><br></pre></td></tr></table></figure></p>
<h1 id="矩阵与行列式"><a href="#矩阵与行列式" class="headerlink" title="矩阵与行列式"></a>矩阵与行列式</h1><p>矩阵</p>
<script type="math/tex; mode=display">\begin{matrix}
1&&2&&3\\
4&&5&&6
\end{matrix}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;matrix&#125;</span><br><span class="line">1&amp;&amp;2&amp;&amp;3\\</span><br><span class="line">4&amp;&amp;5&amp;&amp;6</span><br><span class="line">\end&#123;matrix&#125;$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{bmatrix}
1&&2&&3\\
4&&5&&6
\end{bmatrix}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;bmatrix&#125;</span><br><span class="line">1&amp;&amp;2&amp;&amp;3\\</span><br><span class="line">4&amp;&amp;5&amp;&amp;6</span><br><span class="line">\end&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure>
<p>行列式</p>
<script type="math/tex; mode=display">\begin{vmatrix}
1&&2&&3\\
4&&5&&6
\end{vmatrix}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;bmatrix&#125;</span><br><span class="line">1&amp;&amp;2&amp;&amp;3\\</span><br><span class="line">4&amp;&amp;5&amp;&amp;6</span><br><span class="line">\end&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>n皇后问题</title>
    <url>/yzhiwei.github.io/2019/01/30/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Problem Description<br>在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。<br>你的任务是，对于给定的N，求出有多少种合法的放置方法。</p>
<p>Input</p>
<p>共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。</p>
<p>Output</p>
<p>共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。</p>
<p>Sample Input<br>1<br>8<br>5<br>0</p>
<p>Sample Output<br>1<br>92<br>10</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>要求不在同一行，同一列，对角线上<br>我们可以开一个数组，用数组的下标表示不在同一行，那么不在同一列则是对与下标不同的值他的值也不同<br>在对角线上不同我们可以采用他们的纵坐标的差不等于横坐标的差来表示</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int x[15],y[15]={0},n,sum;
bool place(int k)
{
for(int i=1;i&lt;k;i++)
{
    if(x[k]==x[i]||abs(x[k]-x[i])==abs(k-i))
    return 0;
}
return 1;
}
void dfs(int a)
{
int i;
if(i&gt;n)
sum++;
else
for(int i=1;i&lt;=n;i++)
{
    x[a]=i;
    if(place(a))
    dfs(a+1);
}
}
int main()
{
  int j;
  for(int i=1;i&lt;=10;i++)
  {
      n=i;
      sum=0;
      dfs(1);
      y[i]=sum;
   } 
   while(cin&gt;&gt;j&amp;&amp;j)
   {
       cout&lt;&lt;y[j]&lt;&lt;endl;
   }
   return 0;
}
</code></pre><h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><p>这些老火的深搜题，其实题都是很好懂的，也很好看出来应该在那些地方剪枝，但总感觉代码实现很有难度，应该还是自己敲的次数太少了吧。</p>
]]></content>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>使用mathjax渲染latex公式</title>
    <url>/yzhiwei.github.io/2019/07/22/%E4%BD%BF%E7%94%A8mathjax%E6%B8%B2%E6%9F%93latex%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="卸载默认的渲染引擎"><a href="#卸载默认的渲染引擎" class="headerlink" title="卸载默认的渲染引擎"></a>卸载默认的渲染引擎</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
<h1 id="安装hexo-renderer-kramed引擎"><a href="#安装hexo-renderer-kramed引擎" class="headerlink" title="安装hexo-renderer-kramed引擎"></a>安装hexo-renderer-kramed引擎</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<h1 id="改变文件配置"><a href="#改变文件配置" class="headerlink" title="改变文件配置"></a>改变文件配置</h1><p>打开<strong>/node_modules/hexo-renderer-kramed/lib/renderer.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Change inline math rule</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    // Fit kramed&apos;s rule: $$ + \1 + $$</span><br><span class="line">    return text.replace(/`\$(.*?)\$`/g, &apos;$$$$$1$$$$&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为，直接返回text</span><br><span class="line"></span><br><span class="line">// Change inline math rule</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    return text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="卸载hexo-math"><a href="#卸载hexo-math" class="headerlink" title="卸载hexo-math"></a>卸载hexo-math</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>
<h1 id="安装hexo-renderer-mathjax包"><a href="#安装hexo-renderer-mathjax包" class="headerlink" title="安装hexo-renderer-mathjax包"></a>安装hexo-renderer-mathjax包</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>
<h1 id="更改默认转义规则"><a href="#更改默认转义规则" class="headerlink" title="更改默认转义规则"></a>更改默认转义规则</h1><p>reason：latex语法与markdown语法有冲突</p>
<p>打开<strong>/node_modules\kramed\lib\rules\inline.js</strong></p>
<p>将<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">改为</span><br><span class="line">escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">改为</span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>需要letex公式时，在头部加入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mathjax： true</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>写于生日当天</title>
    <url>/yzhiwei.github.io/2019/07/20/%E5%86%99%E4%BA%8E21%E5%B2%81%E7%94%9F%E6%97%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script>
<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />
    <label for="pass">Please enter the password to read the blog.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/yzhiwei.github.io/lib/crypto-js.js"></script><script src="/yzhiwei.github.io/lib/blog-encrypt.js"></script><link href="/yzhiwei.github.io/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>写于博客建成之后</title>
    <url>/yzhiwei.github.io/2019/01/24/%E5%86%99%E4%BA%8E%E5%8D%9A%E5%AE%A2%E5%BB%BA%E6%88%90%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script>
<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />
    <label for="pass">Please enter the password to read the blog.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/yzhiwei.github.io/lib/crypto-js.js"></script><script src="/yzhiwei.github.io/lib/blog-encrypt.js"></script><link href="/yzhiwei.github.io/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树（kruskal）</title>
    <url>/yzhiwei.github.io/2019/03/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88kruskal%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>kruskal是先选确定边最小的一条边，然后依次确定各条边，要确保生成的最小生成树不闭合。</p>
<p>采用并查集实现算法。</p>
<h1 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h1><h2 id="边"><a href="#边" class="headerlink" title="边"></a>边</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bian</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> start,end,power;</span><br><span class="line">&#125;node[<span class="number">5050</span>]; <span class="comment">//每条边的定义</span></span><br></pre></td></tr></table></figure>
<h2 id="按照权值大小排序"><a href="#按照权值大小排序" class="headerlink" title="按照权值大小排序"></a>按照权值大小排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(bian a,bian b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.power&lt;b.power;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找的部分"><a href="#查找的部分" class="headerlink" title="查找的部分"></a>查找的部分</h2><p>这一部分有必要解释一些原理,我们需要查找的是每一个点的“上级”，即通过它我们最多可以到什么地方，举个例子，如果a能到b，b能到c，那么a也能够到达c点，这时，我们就可以定义c为a，b的上级，我们需要的就是找到每一个点的上级。</p>
<p>我们先假设每一个点的上级为它本身<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> father[<span class="number">5000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">	father[i]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查找<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[x]==x?x,find(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查找了每一个上级，此时会有若干个分枝，现在需要做到的就是将若干个分支给合并，此时我们先判断两个点他们的上级是否相同，若不同，这将他们的一个上级变为另外一个上级的下级，这样，这两点便能够连在一起。</p>
<p>合并<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx=find(x);</span><br><span class="line">	<span class="keyword">int</span> fy=find(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy) <span class="comment">//两个点上级不一样</span></span><br><span class="line">	&#123;</span><br><span class="line">		father[fx]=fy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="完整的一个代码"><a href="#完整的一个代码" class="headerlink" title="完整的一个代码"></a>完整的一个代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">5050</span>],a[<span class="number">5050</span>],b[<span class="number">5050</span>];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bian</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> start,end,power;</span><br><span class="line">&#125;node[<span class="number">5050</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.power&lt;b.power;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	father[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pre[x]==x?x,find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx=find(x);</span><br><span class="line">	<span class="keyword">int</span> fy=find(y);</span><br><span class="line">	<span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">		pre[fx]=fy;</span><br><span class="line">		sum+=node[i].power;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;node[i].start&gt;&gt;node[i].end&gt;&gt;node[i].power;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(node,node+m,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(find(node[i].start!=node[i].end))&#123;</span><br><span class="line">            a[j]=node[i].start;</span><br><span class="line">            b[j]=node[i].end;</span><br><span class="line">            j++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	combine(node[i].start,node[i].start,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        	<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;b[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>将sublime用来写c/c++程序</title>
    <url>/yzhiwei.github.io/2019/01/27/%E5%B0%86sublime%E7%94%A8%E6%9D%A5%E5%86%99c-c-%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="sublime简介"><a href="#sublime简介" class="headerlink" title="sublime简介"></a>sublime简介</h1><p>sublime是一个文本编辑软件，相当于电脑自带的记事本，但因其有很高的颜值，深受人们喜爱，但作为程序员来讲，学会用sublime写代码是一件很赏心悦目的事情。</p>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="编译器的安装"><a href="#编译器的安装" class="headerlink" title="编译器的安装"></a>编译器的安装</h2><p>如果你的电脑中带有vs，codeblock等软件，你需要找到一个名为GW的文件夹，并将它复制到C盘根目录下面<br>如果你的电脑中没有编译软件，那么你需要在网上下载GW文件。</p>
<h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>打开此电脑-属性-高级系统设置-环境变量-系统变量<br>将C:\MinGW64\bin加入到path中</p>
<h2 id="sublime中的设置"><a href="#sublime中的设置" class="headerlink" title="sublime中的设置"></a>sublime中的设置</h2><p>依次打开tools-build system—new build system<br>输入以下代码：</p>
<pre><code>{
//&quot;shell_cmd&quot;: &quot;make&quot;
&quot;working_dir&quot;: &quot;$file_path&quot;,
&quot;cmd&quot;: &quot;gcc -Wall \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,
&quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,
&quot;selector&quot;: &quot;source.c&quot;,
&quot;variants&quot;: 
[
    {   
    &quot;name&quot;: &quot;Run&quot;,
        &quot;shell_cmd&quot;: &quot;gcc -Wall \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; \&quot;${file_path}/${file_base_name}\&quot;&quot;
    }
]
}
</code></pre><p>ctrl+s 保存，名字随意就好</p>
<h1 id="运行你的c-c-程序"><a href="#运行你的c-c-程序" class="headerlink" title="运行你的c/c++程序"></a>运行你的c/c++程序</h1><ol>
<li>tools-build with</li>
<li>ctrl shift b </li>
</ol>
<h1 id="一些可以改进的地方"><a href="#一些可以改进的地方" class="headerlink" title="一些可以改进的地方"></a>一些可以改进的地方</h1><h2 id="快捷键的设置"><a href="#快捷键的设置" class="headerlink" title="快捷键的设置"></a>快捷键的设置</h2><p>  许多人习惯了采用vs和dev这些编译器，希望只用一个f9便能够编译加运行，此时，我们在添加一行代码就好。</p>
<pre><code>[
{“keys”: [“f9”], “command”: “build”, “args”: {“variant”: “RunInCommand”}}
]
</code></pre>]]></content>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/yzhiwei.github.io/2019/07/29/%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>根据边的方向： 有向图，无向图</p>
<p>路径： 从某个点出发经过若干条边到达另一个点</p>
<p>简单路径： 不重复经过某个点的路径</p>
<p>度数： 无向图中一个点连出去边的个数</p>
<p>连通： 两个点通过路径相连</p>
<p>拓扑图： 没有环的图</p>
<h1 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>利用stl里的vector存图</p>
<p>将点i的出边，存在一个vector数组中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5250    <span class="comment">//最大点数;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,v;    <span class="comment">//to代表到哪个顶点，v代表权值</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; e[maxn];    <span class="comment">//每个点都有自己的邻接表，vector是一个node类型的数组</span></span><br></pre></td></tr></table></figure>
<p>插入边<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span>    <span class="comment">//u-&gt;v = w;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node tmp;</span><br><span class="line">    tmp.to = v;</span><br><span class="line">    tmp.v = w;</span><br><span class="line">    e[u].push_back(tmp);    <span class="comment">//关于顶点u的邻接表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遍历<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[<span class="number">1</span>].size(); i++)    <span class="comment">//遍历1号顶点所有出边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;e[<span class="number">1</span>][i].to&lt;&lt;e[<span class="number">1</span>][i].v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h1><p><a href="https://blog.csdn.net/qq_36386435/article/details/77403223?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://blog.csdn.net/qq_36386435/article/details/77403223?tdsourcetag=s_pctim_aiomsg</a></p>
<h2 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h2><p>给定一张n个点m条边的有向图，每条边的长度为1，求1号点到其他点的最短路径</p>
<p>如果1到x的最短路为<code>L</code>,那么肯定存在一个y，使得1到y的最短路为<code>L-1</code>，且y到x有边。</p>
<p>用队列维护这个拓展的过程</p>
<p>时间复杂度 O（n+m）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">	<span class="keyword">for</span>(x,y)</span><br><span class="line">	push(y);</span><br><span class="line">	<span class="keyword">if</span>(d[y]&gt;d[x]+<span class="number">1</span>)&#123;</span><br><span class="line">	d[y]=d[x]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="v2"><a href="#v2" class="headerlink" title="v2"></a>v2</h2><p>给定一张n个点m条边的有向图，每条边的长度为1或0，求1号点到其他点的最短路径</p>
<p>改一下bfs</p>
<p>如果两点间距离为0，则将这两点合并（并查集）</p>
<p>if w(x,y)=0;<br>father[x]=y;</p>
<h2 id="v3"><a href="#v3" class="headerlink" title="v3"></a>v3</h2><p>给定一张n个点m条边的有向图，每条边的长度为1或2，求1号点到其他点的最短路径</p>
<p>把长度为2的边拆为长度为1的边</p>
<p>w(x,y)=w(x,z)+w(z,y)</p>
<h2 id="v4"><a href="#v4" class="headerlink" title="v4"></a>v4</h2><p>给定一张n个点m条边的正权有向图，求1号点到其他点的最短路径</p>
<p>按照最短路的大小从小到大加入队列，用优先队列进行维护</p>
<p>时间复杂度：O(n+mlogn) 或 O(<script type="math/tex">n^2</script>+m)</p>
<p>不能处理带负权的边</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">1</span>&lt;&lt;<span class="number">29</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1010</span>][<span class="number">1010</span>];<span class="comment">//map[i][j]表示从i--&gt;j的距离  </span></span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">1010</span>];<span class="comment">//dist[i]从v1到i的距离  </span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1010</span>];<span class="comment">//标记有没有被访问过  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,min;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i]=<span class="built_in">map</span>[<span class="number">1</span>][i];</span><br><span class="line">        vis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//遍历顶点  </span></span><br><span class="line">    &#123;</span><br><span class="line">        k=<span class="number">0</span>;</span><br><span class="line">        min=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;dist[j]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min=dist[j];</span><br><span class="line">                k=j;</span><br><span class="line">            &#125;</span><br><span class="line">        vis[k]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;dist[k]+<span class="built_in">map</span>[k][j]&lt;dist[j])</span><br><span class="line">                dist[j]=dist[k]+<span class="built_in">map</span>[k][j];<span class="comment">//如果找到了通路就加上 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="v1-v4"><a href="#v1-v4" class="headerlink" title="v1-v4"></a>v1-v4</h2><p>带有贪心策略的广度优先搜素</p>
<h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h2><p>给定一张n个点m条边的有向图，求1号点到每个点的最短路</p>
<p>每次拿每条边去更新最短路</p>
<p>时间复杂度 O(n<code>*</code>m)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n<span class="number">-1</span>;k++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dis[v[i]]&gt;dis[[u[i]]]+w[i])&#123;</span><br><span class="line">			dis[v[i]]=dis[u[i]]+w[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>bellman-ford的优化</p>
<p>对于一条边(u,v),在dis[u]没变的情况下不应该重新更新</p>
<p>用队列记录要进行拓展的点，每次dis[x]被更新后就把x扔进队列里去更新其他点的最短路</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,src;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> inque[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">63</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    dis[src]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) que.pop();</span><br><span class="line">    que.push(src);</span><br><span class="line">    inque(src)=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[u].size;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[u]+g[u][i].second&lt;dist[g[u][i].first])&#123;</span><br><span class="line">                dist[g[u][i].first]=dist[u]+g[u][i].second;</span><br><span class="line">              <span class="keyword">if</span>(!inque[g[u][i].first])&#123;</span><br><span class="line">                inque[g[u][i]].first=<span class="literal">true</span>;</span><br><span class="line">                que.push(g[u][i].first);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inque[u]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="卡SPFA"><a href="#卡SPFA" class="headerlink" title="卡SPFA"></a>卡SPFA</h2><p>建一个n<code>*</code>m的网格图，其中行数很少，列数很多</p>
<p>行与行的边权都较小，列与列的边权都较大</p>
<h2 id="判断负环"><a href="#判断负环" class="headerlink" title="判断负环"></a>判断负环</h2><p>记录len[x],表示1到x的最短路的点的个数，len[x]&gt;=n时存在负环</p>
<p>时间复杂度 O(n<code>*</code>m)</p>
<h2 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h2><p>给定一张n个点m条边的有向图，求每两个点之间的最短路</p>
<p>f(K,X,Y)表示x到y的路径中，满足路径上的点标号都不超过k的最短路径</p>
<p>动态规划进行松弛操作</p>
<p>f(K,X,Y)=min(F(K-1,X,Y),f(k-1,X,K)+f(K-1,K,Y))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">			f[i][j]=min(f[i][j],f[i][k]+f[k][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度<br>O(<script type="math/tex">n^3</script>)</p>
<h1 id="差分约束问题"><a href="#差分约束问题" class="headerlink" title="差分约束问题"></a>差分约束问题</h1><p>假设对于一张图来说，1号点到x的最短路长度为d[x]</p>
<p>则有 d[y]&lt;=d[x]+w[x][y];</p>
<p>最短路可以给出这类问题的最大解，取反后记得最小解</p>
<p>对于解不等式，有很多解</p>
<p>对于存在负环的图，无解</p>
<p>提供了一种判断差分约束问题有无解的方法,判断是否存在负环</p>
<p>给定n,m和m个三元组(l,r,k),求一个01串s,使得s[l…r]中1的个数至少有k个，求1最少的满足条件的01串</p>
<p>将区间和用前缀和表示</p>
<p>设f[i]为s[1…i]中1的个数</p>
<p>f[i]&lt;=f[i-1]+1;<br>f[i-1]&lt;=f[i];<br>f[l-1]&lt;=f[r]-k;</p>
<h1 id="次短路"><a href="#次短路" class="headerlink" title="次短路"></a>次短路</h1><p>定义：若d[v]=d[u]+w(u,v),则称(u,v)是最短路图上的边</p>
<p>1—-u—-v—-n</p>
<p>1-u和v-n都是最短路</p>
<p>枚举边w(u,v),若d(u) &lt; d[v]+w(u,v),则uv不是最短路上面的边</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> R = <span class="number">100000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;<span class="comment">//存储前一个点在数组的位置</span></span><br><span class="line">&#125; edge[R*<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> head[R];<span class="comment">//存储最后一个点每个点在的数组位置</span></span><br><span class="line"><span class="keyword">int</span> dist1[R],dist2[R];<span class="comment">//距离数组，分别求1到所有点距离和n到所有点距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[R];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(dist1,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist1));</span><br><span class="line">    <span class="built_in">memset</span>(dist2,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist2));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span><span class="comment">//邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[num].v = v;</span><br><span class="line">    edge[num].w = w;</span><br><span class="line">    edge[num].next = head[u];</span><br><span class="line">    head[u] = num++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> *dist)</span><span class="comment">//u是给定点 dist是距离数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,v,w;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dist[u] = <span class="number">0</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    Q.push(u);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=head[u]; i!=<span class="number">-1</span>; i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].v;</span><br><span class="line">            w = edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] &gt; dist[u] + w)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    Q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)<span class="comment">//n个点，m条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="comment">//无向图，双向间图</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add_edge(u,v,w);</span><br><span class="line">            add_edge(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line">        SPFA(<span class="number">1</span>,dist1);<span class="comment">//求 1 到所有点的最短路</span></span><br><span class="line">        SPFA(n,dist2);<span class="comment">//求 n 到所有点的最短路</span></span><br><span class="line">        <span class="keyword">int</span> ans = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//遍历每个点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=head[i]; j!=<span class="number">-1</span>; j=edge[j].next)<span class="comment">//与i点相连的边</span></span><br><span class="line">            &#123;</span><br><span class="line">                v = edge[j].v;</span><br><span class="line">                w = edge[j].w;</span><br><span class="line">                <span class="comment">// 1 到 i这一点的最短路， n 到 j这一点的最短路 + edge[i][j]</span></span><br><span class="line">                <span class="keyword">int</span> tem = dist1[i] + dist2[v] + w;</span><br><span class="line">                <span class="keyword">if</span>(tem &gt; dist1[n] &amp;&amp; tem &lt; ans)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = tem;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h1><p>无向图的连通： 两个点存在一条连接的路径</p>
<p>连通块： 里面的点两两连通的块</p>
<p>连通具有传递性，不连通不具有传递性。</p>
<h2 id="维护连通性"><a href="#维护连通性" class="headerlink" title="维护连通性"></a>维护连通性</h2><p>对于每个连通块维护一个有根树，f(x)表示x的根</p>
<p>假设我们添加一条边u,v,首先求出u,v所在连通块的有根树树根x,y,然后令f(x)=y</p>
<h1 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h1><p>对于一个连通无向图，定义1条边(u,v)是桥,当且仅当断开这条边后图变得不连通</p>
<p>强连通分量： 没有桥的连通块</p>
<p>dfn:表示顶点在dfs中的遍历顺序<br>low：不通过父节点能访问到的祖先节点中最小的顺序值</p>
<h2 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,next;</span><br><span class="line">&#125;edge[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> DFN[<span class="number">1001</span>],LOW[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">1001</span>],heads[<span class="number">1001</span>],visit[<span class="number">1001</span>],cnt,tot,index;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].next=heads[x];</span><br><span class="line">    edge[cnt].v = y;</span><br><span class="line">    heads[x]=cnt;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//代表第几个点在处理。递归的是点。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DFN[x]=LOW[x]=++tot;<span class="comment">// 新进点的初始化。</span></span><br><span class="line">    <span class="built_in">stack</span>[++index]=x;<span class="comment">//进站</span></span><br><span class="line">    visit[x]=<span class="number">1</span>;<span class="comment">//表示在栈里</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=heads[x];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!DFN[edge[i].v]) &#123;<span class="comment">//如果没访问过</span></span><br><span class="line">            tarjan(edge[i].v);<span class="comment">//往下进行延伸，开始递归</span></span><br><span class="line">            LOW[x]=min(LOW[x],LOW[edge[i].v]);<span class="comment">//递归出来，比较谁是谁的儿子／父亲，就是树的对应关系，涉及到强连通分量子树最小根的事情。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(visit[edge[i].v ])&#123;  <span class="comment">//如果访问过，并且还在栈里。</span></span><br><span class="line">            LOW[x]=min(LOW[x],DFN[edge[i].v]);<span class="comment">//比较谁是谁的儿子／父亲。就是链接对应关系</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(LOW[x]==DFN[x]) <span class="comment">//发现是整个强连通分量子树里的最小根。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="built_in">stack</span>[index]);</span><br><span class="line">            visit[<span class="built_in">stack</span>[index]]=<span class="number">0</span>;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;<span class="keyword">while</span>(x!=<span class="built_in">stack</span>[index+<span class="number">1</span>]);<span class="comment">//出栈，并且输出。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(heads,<span class="number">-1</span>,<span class="keyword">sizeof</span>(heads));</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        add(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         <span class="keyword">if</span>(!DFN[i])  tarjan(<span class="number">1</span>);<span class="comment">//当这个点没有访问过，就从此点开始。防止图没走完</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2019/08/05/egCJit.png" alt="1"></p>
<h2 id="无向图求割点和桥"><a href="#无向图求割点和桥" class="headerlink" title="无向图求割点和桥"></a>无向图求割点和桥</h2><p>割点：无向连通图中，去掉一个定点和它相邻的所有边，图中的连通分块增加</p>
<p>桥：去掉一条边，图中的连通分量数增加</p>
<p>有割点不一定有桥</p>
<p>桥一定是割点依附的边</p>
<p>割点：如果一个点的所有孩子节点可以不通过父亲节点直接访问到祖先节点，那么这个点不是割点</p>
<p>桥：low[v]&gt;dnf(u),就说明v-u是桥</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 201</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G[N];</span><br><span class="line"><span class="keyword">int</span> n,m,low[N],dfn[N];</span><br><span class="line"><span class="keyword">bool</span> is_cut[N];</span><br><span class="line"><span class="keyword">int</span> father[N];</span><br><span class="line"><span class="keyword">int</span> tim=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        G[a].push_back(b);<span class="comment">/*邻接表储存无向边*/</span></span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> Father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    father[i]=Father;<span class="comment">/*记录每一个点的父亲*/</span></span><br><span class="line">    dfn[i]=low[i]=tim++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G[i].size();++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=G[i][j];</span><br><span class="line">        <span class="keyword">if</span>(dfn[k]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(k,i);</span><br><span class="line">            low[i]=min(low[i],low[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Father!=k)<span class="comment">/*假如k是i的父亲的话，那么这就是无向边中的重边，有重边那么一定不是桥*/</span></span><br><span class="line">            low[i]=min(low[i],dfn[k]);<span class="comment">//dfn[k]可能！=low[k]，所以不能用low[k]代替dfn[k],否则会上翻过头了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootson=<span class="number">0</span>;</span><br><span class="line">    Tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=father[i];</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">1</span>)</span><br><span class="line">        rootson++;<span class="comment">/*统计根节点子树的个数，根节点的子树个数&gt;=2,就是割点*/</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(low[i]&gt;=dfn[v])<span class="comment">/*割点的条件*/</span></span><br><span class="line">            is_cut[v]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rootson&gt;<span class="number">1</span>)</span><br><span class="line">    is_cut[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">if</span>(is_cut[i])</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=father[i];</span><br><span class="line">        <span class="keyword">if</span>(v&gt;<span class="number">0</span>&amp;&amp;low[i]&gt;dfn[v])<span class="comment">/*桥的条件*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,v,i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input();</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(father,<span class="number">0</span>,<span class="keyword">sizeof</span>(father));</span><br><span class="line">    <span class="built_in">memset</span>(low,<span class="number">-1</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(is_cut,<span class="literal">false</span>,<span class="keyword">sizeof</span>(is_cut));</span><br><span class="line">    count();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><p>给定一张有向图，如何求出一条经过每条边恰好一次的回路</p>
<p>必要条件：</p>
<p>1.这张图是一个强联通分量</p>
<p>2.每个点出度等于入度</p>
<p>这两个条件同时也是充分的</p>
<p>圈套圈算法</p>
<p>任选一个起点，从起点开始dfs,每个边只能被走一遍，当没有边走的时候把x压入答案的队列中。</p>
<p>dfs(x){<br>    for(x,y)<br>    dfs(y)<br>    x—ans<br>}</p>
<p>最后求出的是一个反着的欧拉回路</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树：n个点n-1条边的连通无向图，分为有根树和无根树</p>
<p>树的叶子：度数为0的点</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>给定一张n个点的带权无向图，求权值最小的生成树</p>
<p>kruskal算法： 将边按照权值大小排序，之后能加就加，用并茶几维护</p>
<p>prim算法： 按照点进行贪心</p>
<p>证明：数学归纳法，假设法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5000</span>;</span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start,ed,power;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.power&lt;b.power;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> father[x]==x?x:find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x);</span><br><span class="line">    <span class="keyword">int</span> fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        father[fx]=fy;</span><br><span class="line">        sum+=z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            father[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;e[i].start&gt;&gt;e[i].ed&gt;&gt;e[i].power;</span><br><span class="line">        sort(e,e+n,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            join(e[i].start,e[i].ed,e[i].power);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prufer序列"><a href="#prufer序列" class="headerlink" title="prufer序列"></a>prufer序列</h2><p>将一棵树变成一个序列</p>
<p>每次选择树上标号最小的叶子，删掉它，将与它相连的那个点的标号加到序列里，直到只剩下两个点。</p>
<p>可以证明：任意一个长度为n-2的1…n的序列都是某颗树的prufer序列</p>
<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>可以分成两部分，使得这两部分内部没有边的图</p>
<p>一个图是二分图等价于该图没有奇环</p>
<h2 id="二分图的匹配"><a href="#二分图的匹配" class="headerlink" title="二分图的匹配"></a>二分图的匹配</h2><p>一个匹配是一个边的集合，其中任意两条边都没有公共顶点</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eycwRJ.png" alt="1"></p>
<p>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配</p>
<p>完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，就是一个完美匹配</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eygeyR.png" alt="1"></p>
<p>完美匹配：所有男孩和女孩都配对，使的每对都相互喜欢</p>
<p>最大匹配：最多有多少互相喜欢的男孩/女孩</p>
<p>交替路：从一个未匹配点出发，依次经过非匹配边，匹配边…形成的路径</p>
<p>增广路，从一个未匹配点出发，走交替路，如果途径另一个未匹配点，则这条交替路成为增广路。</p>
<p><a href="https://blog.csdn.net/ling_wang/article/details/79830980" target="_blank" rel="noopener">https://blog.csdn.net/ling_wang/article/details/79830980</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn];<span class="comment">//edge[i][j] == 1 代表i，j可以匹配</span></span><br><span class="line"><span class="keyword">int</span> vis[maxn];<span class="comment">//用来记录该点是否被访问过</span></span><br><span class="line"><span class="keyword">int</span> cx[maxn], cy[maxn];<span class="comment">//用来记录x集合中匹配的y元素是哪个</span></span><br><span class="line"><span class="keyword">int</span> nx, ny;<span class="comment">//nx表示x集合的顶点个数， ny表示y集合的顶点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">line</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; ny; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[u][v] &amp;&amp; !vis[v])&#123;</span><br><span class="line">            vis[v] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cy[v] == <span class="number">-1</span> || line(cy[v]))&#123;<span class="comment">//如果y集合中的v没有匹配或v已经匹配，但从cy[v]中可以找到一条增广路</span></span><br><span class="line">                cx[u] = v;<span class="comment">//找到增广路，修改匹配</span></span><br><span class="line">                cy[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxmatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">    <span class="built_in">memset</span>(cx, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(cx));<span class="comment">//初始值为-1表示两个集合中都没有匹配的元素</span></span><br><span class="line">    <span class="built_in">memset</span>(cy, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(cy));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= nx; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cx[i] == <span class="number">-1</span>)&#123;<span class="comment">//还没被匹配就执行内部代码</span></span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//重置标记为未访问</span></span><br><span class="line">            sum += line(i);<span class="comment">//以 i 为起点开始查找增广路，返回true ，匹配数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t) &amp;&amp; t)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nx, &amp;ny);</span><br><span class="line">        <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            edge[x][y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = maxmatch();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图染色"><a href="#二分图染色" class="headerlink" title="二分图染色"></a>二分图染色</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g[<span class="number">200005</span>];<span class="comment">//通过邻接表的方式存储可以存入更多的点</span></span><br><span class="line"><span class="keyword">int</span> color[<span class="number">200005</span>];<span class="comment">//存储当前点的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> n,m,x,y,i;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			g[i].clear();</span><br><span class="line">			color[i]=<span class="number">0</span>;<span class="comment">//初始化，表示当前点未染色</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">			g[x].push_back(y);</span><br><span class="line">			g[y].push_back(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(bfs(<span class="number">1</span>))<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.push(u);</span><br><span class="line">	color[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[t].size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(color[g[t][i]]==color[t])<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果当前点和该点相连的另一点的颜色相同，那么证明该图不是二分图</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!color[g[t][i]])<span class="comment">//如果不相等，且当前点未染色，那么进行染色，并将该点推入队列中</span></span><br><span class="line">			&#123;</span><br><span class="line">				color[g[t][i]]=-color[t];</span><br><span class="line">				q.push(g[t][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>深搜题（hdu1455)</title>
    <url>/yzhiwei.github.io/2019/01/27/%E6%B7%B1%E6%90%9C%E9%A2%98%EF%BC%88hdu1455/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>Problem Description<br>George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero.</p>
<p>Input<br>The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero.</p>
<p>Output<br>The output file contains the smallest possible length of original sticks, one per line.</p>
<p>Sample Input<br>9<br>5 2 1 5 2 1 5 2 1<br>4<br>1 2 3 4<br>0</p>
<p>Sample Output<br>6 5</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定n个已经被分割棒子的长度，如题面中的1，2，3，4.代表4个被分割绳子的长度，要求求出原绳子的最小长度（原绳子等长）即本题绳子长度为5，5=2+3，5=1+4</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先我们应该确定绳子的长度，绳子的最小长度应该为被分割绳子的最长长度，绳子的最大长度应该为被分割绳子的总长度<br>max（1，2，3，4）&lt;绳长&lt;sum(1,2,3,4)</p>
<p>下面我们应该应该排除一些情况<br>1.sum=10，那么绳长就不应该是9，8，7，6，4，3<br>2.max=4，那么绳长就不应该是1，2，3<br>综合以上情况，绳长的可能性应该是9，8，7，6，4</p>
<p>下面就应该是对绳子组合的一些具体排除<br>（要对绳子长度从大到小排序）</p>
<ol>
<li><p>如绳子长度为8，7，3，2<br>我们选取最小值为8，对于7而言，7+1=8，而在后面并没有出现1，此时，我们便可以排除8这一种情况。</p>
</li>
<li><p>若绳子长度为8，6，3，3<br>我们选取最小值为8，对于6而言，6+2=8；此时3不符合情况，对后面的3可以直接跳过</p>
</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
using namespace std;
int n,cnt,sum;//n表示木棍的数量，sum表示n个木棍的总长度，cnt=sum/i;
struct node
{
  int lenth ;// 木棍的长度
  int mark; //标记这根木棍是否被用过;
 }stick[66];             
int cmp(node a,node b) //按长度从大到小排序
{
 return a.lenth&gt;b.lenth;
}                        //比较排序
//len为当前木棒的长度，count统计当前长度木棒的数量，
int dfs(int len,int count,int l,int pos)
{
if(len==sum) return 1; //递归出口
if(count==cnt)   return 1; //这个写不写都无所谓，上面一行就ok
for(int i=pos;i&lt;n;i++)
{           
  if(stick[i].mark)continue; //如果木棍被标记过，跳过去
  if(len==(stick[i].lenth+l))
  {
      stick[i].mark=1;  //修改标记
      if(dfs(len,count+1,0,0))  return 1;
      stick[i].mark=0;  //标记还原
      return 0;
  }
  else if(len&gt;(stick[i].lenth+l))
  {
      stick[i].mark=1;
      l+=stick[i].lenth;
      if(dfs(len,count,l,i+1))
         return 1;
      l-=stick[i].lenth;  //如果不能拼接，那么就恢复
      stick[i].mark=0;
      if(l==0) return 0;
      while(stick[i].lenth==stick[i+1].lenth)i++;  //这是一条非常重要的剪枝，可以极大的降低时间复杂度
 return 0;
}
int main()
{
    while(cin&gt;&gt;n&amp;&amp;n) 
    {
       cnt=sum=0;
       for(int i=0;i&lt;n;i++)
       {
           cin&gt;&gt;stick[i].lenth;
           sum+=stick[i].lenth;
           stick[i].mark=0; //初始标记为0
       }
       sort(stick,stick+n,cmp); //对长度进行排序
       for(int i=stick[0].lenth;i&lt;=sum;i++)
       {
          if(sum%i)continue; //对长度进行选择
          cnt=sum/i;  
          if(dfs(i,0,0,0))
          {
             printf(&quot;%d\n&quot;,i);
             break;
          }
       }
    }
    return 0;
}
</code></pre><h1 id="dfs最关键的代码结构块"><a href="#dfs最关键的代码结构块" class="headerlink" title="dfs最关键的代码结构块"></a>dfs最关键的代码结构块</h1><pre><code>void dfs()//参数用来表示状态  
{  
if(到达终点状态)  
{  
    ...//根据题意添加  
    return;  
}  
if(越界或者是不合法状态)  
    return;  
if(特殊状态)//剪枝
    return ;
for(扩展方式)  
{  
    if(扩展方式所达到状态合法)  
    {  
        修改操作;//根据题意来添加  
        标记；  
        dfs（）；  
        (还原标记)；  
        //是否还原标记根据题意  
        //如果加上（还原标记）就是 回溯法  
    }  

}  
}  
</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这是做过的第一道深搜题，还是不能够完全理解递归的过程。dfs题型很多，需要多多总结。</p>
<p>sort排序的一种新形式get</p>
]]></content>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>独立数据结构和算法—stl</title>
    <url>/yzhiwei.github.io/2019/01/30/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E2%80%94stl/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>stl独立于数据结构和算法，体现了泛型编程的思想。</p>
<h1 id="stl组成"><a href="#stl组成" class="headerlink" title="stl组成"></a>stl组成</h1><p>stl包含迭代器，容器，算法，函数对象，适配器</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>连接算法和容器之间的纽带。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>物所属的地方</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这个没啥子可说的</p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>重载了operator（）运算符的对象</p>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>通过特定组合的容器实现的一种新的数据结构</p>
<h1 id="本篇重点-算法"><a href="#本篇重点-算法" class="headerlink" title="本篇重点-算法"></a>本篇重点-算法</h1><h2 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h2><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
int a[]={1,5,3,6,4};
sort(a,a+sizeof(a)/sizeof(int));
for (int i = 0; i &lt; sizeof(a)/sizeof(int); ++i)
{
    cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
}
return 0;
}
</code></pre><p>这是最简单的一种情况，将一个数组从大到小排序<br>这当中不一定是对全部内容进行排序，可以对部分连续数组进行排序，规则为左闭右开。</p>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
int a[]={1,5,3,6,4};
sort(a,a+sizeof(a)/sizeof(int),greater&lt;int&gt;());
for (int i = 0; i &lt; sizeof(a)/sizeof(int); ++i)
{
    cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
}
return 0;
}
</code></pre><p>这一种用了greater<int>,将数组给从大到小输出</int></p>
<h3 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h3><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
struct fun
{
    bool operator() (const int &amp;a,const int &amp;b){
       return a%10&gt;b%10;
}    
};
int main()
{
int a[]={19,51,32,6,4};
sort(a,a+sizeof(a)/sizeof(int),fun());
for (int i = 0; i &lt; sizeof(a)/sizeof(int); ++i)
{
    cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
}
return 0;
}
</code></pre><p>这当中采用了自定义规则排序，主要是要注意自定义规则的写法。</p>
]]></content>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵快速幂”</title>
    <url>/yzhiwei.github.io/2019/03/06/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E2%80%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>任意个矩阵相乘即为矩阵快速幂</p>
<h1 id="代码实现的思路"><a href="#代码实现的思路" class="headerlink" title="代码实现的思路"></a>代码实现的思路</h1><p>首先，我们可以用一个结构体来储存我们我们需要的矩阵，用一个结构体数组来保存我们最终需要的那一个矩阵。</p>
<h1 id="具体一些代码块"><a href="#具体一些代码块" class="headerlink" title="具体一些代码块"></a>具体一些代码块</h1><h2 id="矩阵的定义"><a href="#矩阵的定义" class="headerlink" title="矩阵的定义"></a>矩阵的定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">juzhen</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">&#125;  <span class="comment">//这个就代表了一个矩阵</span></span><br></pre></td></tr></table></figure>
<h2 id="矩阵相乘表示"><a href="#矩阵相乘表示" class="headerlink" title="矩阵相乘表示"></a>矩阵相乘表示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(juzhen a,juzheng b,n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="keyword">sizeof</span>(temp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	   <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">          	temp[i][j]=a[i][k]*b[k][j];</span><br><span class="line">&#125;  <span class="comment">//实现两个矩阵相乘</span></span><br></pre></td></tr></table></figure>
<h2 id="定义一个单位数组res"><a href="#定义一个单位数组res" class="headerlink" title="定义一个单位数组res"></a>定义一个单位数组res</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		<span class="keyword">if</span>(i==j)</span><br><span class="line">			juzhen.res[i][j]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			juzhen.res[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现n阶，k个矩阵相乘"><a href="#实现n阶，k个矩阵相乘" class="headerlink" title="实现n阶，k个矩阵相乘"></a>实现n阶，k个矩阵相乘</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&amp;<span class="number">1</span>==<span class="number">1</span>)&#123;</span><br><span class="line">		res=cheng(res,a,n)；</span><br><span class="line">	&#125;</span><br><span class="line">    a=cheng(a,a,n);</span><br><span class="line">    n=n&gt;&gt;<span class="number">1</span>; <span class="comment">//n=n/2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="此时res即为我们最后得到的矩阵"><a href="#此时res即为我们最后得到的矩阵" class="headerlink" title="此时res即为我们最后得到的矩阵"></a>此时res即为我们最后得到的矩阵</h2><h1 id="一段完整的代码"><a href="#一段完整的代码" class="headerlink" title="一段完整的代码"></a>一段完整的代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> m[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">&#125;; <span class="comment">//定义结构体矩阵</span></span><br><span class="line"><span class="function">Matrix <span class="title">mul</span><span class="params">(Matrix a, Matrix b, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp.m[i][j] = <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					temp.m[i][j] = (temp.m[i][j] + (a.m[i][k]*b.m[k][j]) % <span class="number">9973</span>) % <span class="number">9973</span>;</span><br><span class="line">				&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;  <span class="comment">//计算两个n阶矩阵相乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; t &gt;&gt; n;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; t &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">		Matrix ans;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == j) ans.m[i][j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> ans.m[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="comment">//定义一个单位数组</span></span><br><span class="line">		Matrix a;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">				<span class="built_in">cin</span> &gt;&gt; a.m[i][j];</span><br><span class="line">		<span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (n &amp; <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = mul(ans, a, t);</span><br><span class="line">				</span><br><span class="line">			&#125;a = mul(a,a,t);</span><br><span class="line">				n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="comment">//计算n个矩阵相乘</span></span><br><span class="line">		<span class="comment">/*for (int i = 0; i &lt; t; i++)</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				for (int j = 0; j &lt; t; j++)</span></span><br><span class="line"><span class="comment">					cout &lt;&lt; ans.m[i][j] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">				cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">			&#125;*/</span></span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == j)</span><br><span class="line">					x = (x + ans.m[i][j]) % <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="comment">//取矩阵对角线元素之和</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络复习</title>
    <url>/yzhiwei.github.io/2019/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>  建立一个tcp连接时，需要客户端和服务端总发送三个包已确定连接的确定<br>  为什么需要3次握手<br>  Tcp是面对连接的，所以<strong>需要双方都确认连接的建立</strong></p>
<p>  <strong>第一次握手</strong><br>  客户端请求建立连接，发送SYN报文段：<br>                    标志位置1<br>                    选择初始序列号</p>
<p>  <strong>第二次握手</strong><br>  服务端应答客户端，并请求建立连接  回应一个SYNACK报文段<br>                                  选择初始序列号告知客户端<br>                                  为服务器分配缓存</p>
<p>  <strong>第三次握手</strong><br>  客户端争对服务器端请求确认应答   回应一个ACK 可以包含数据</p>
<p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4qgpp3h80j30fe0c5q54.jpg" alt="三次握手"></p>
<h3 id="rdt-停等协议"><a href="#rdt-停等协议" class="headerlink" title="rdt(停等协议)"></a>rdt(停等协议)</h3><p>什么是可靠<br>不错，不丢，不乱</p>
<p>基本接口<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4qzem6t7hj31h90n817u.jpg" alt="接口"></p>
<h4 id="rdt-1-0"><a href="#rdt-1-0" class="headerlink" title="rdt 1.0"></a>rdt 1.0</h4><p>不会发生错误<br>不会丢弃分组</p>
<p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4qztdjph3j31gz0g0aig.jpg" alt="fsm"></p>
<h4 id="rdt-2-0"><a href="#rdt-2-0" class="headerlink" title="rdt 2.0"></a>rdt 2.0</h4><p>可能发生位错误</p>
<p>利用<strong>校验和</strong>检测位错误</p>
<p>如何从错误中恢复<br>确认机制（ACK）：接收方显示的告知发送方分组已正确接收<br>NAK：接收方显式的告诉发送方分组有错误<br>发送方收到NAK后，重传分组</p>
<p>rdt2.0引入的新机制<br>差错检测<br>接收方反馈控制信息：ACK/NAK<br>重传</p>
<p>缺陷<br>ACK/NAK可能会发送错误</p>
<p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4r09hn3fpj31hc0ni4by.jpg" alt="fsm"></p>
<h4 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h4><p>为ACK,NAK增加校验和，检错并纠错</p>
<p>如果ACK/NAK坏掉，发送方重传<br>不能简单的重传，产生重复分组</p>
<p>如何解决重复分组问题？<br>序列号：发送方给每个分组增加序列号<br>接收方丢弃重复分组<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4r10me6aej31h10nb7j3.jpg" alt="fsm send"><br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4r12qp977j31ha0nadwu.jpg" alt="fsm rec"></p>
<h4 id="rdt-2-2"><a href="#rdt-2-2" class="headerlink" title="rdt 2.2"></a>rdt 2.2</h4><p>无NAK消息协议</p>
<p>与rdt2.1功能相同，但是只使用ACK<br>如何实现？<br>接收方通过ACK告知最后一个被正确接收的分组<br>在ACK消息中显式的加入被加入的确认号</p>
<p>发送方在收到重复ACK之后，采用与收到NAK消息相同的作用<br>重传当前分组<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4r1agdzp1j31hc0n8nej.jpg" alt="fsm"></p>
<h4 id="rdt-3-0"><a href="#rdt-3-0" class="headerlink" title="rdt 3.0"></a>rdt 3.0</h4><p>信道可能发生错误，也可能丢失分组</p>
<p>方法：发送方等待合理时间<br>如果没收到ACK，重传<br>如果分组或者ACK只是延迟而不是丢了<br>重传会产生重复，序列号机制能够处理<br>接收方须在ACK中显式的告知所确认的分组</p>
<p>需要计时器</p>
<p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4r1u9nkl3j313c0gnajc.jpg" alt="fsm send"></p>
<h4 id="rdt用到的技术"><a href="#rdt用到的技术" class="headerlink" title="rdt用到的技术"></a>rdt用到的技术</h4><p>rdt 1.0 </p>
<p>rdt 2.0 校验和  确认机制</p>
<p>rdt 2.1 校验和  确认机制 序列号</p>
<p>rdt 2.2 校验和  ACK   序列号</p>
<p>rdt 3.0 计时器</p>
<h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p>允许发送方在收到ACK之前就连续发送多个分组</p>
<ol>
<li>更大的序列号范围</li>
<li>发送方和/或接收方需要更大的存储空间来缓存分组<br>窗口<ol>
<li>允许使用的序列号范围</li>
<li>窗口长度为n：最多有n个等待确认的信息</li>
</ol>
</li>
</ol>
<h4 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h4><p>GBN（<strong>累计确认机制</strong>）<br><strong>发送方</strong>：<br>头部分组包含K-bit序列号<br>窗口尺寸为n，最多允许n个分组为确认<br><strong>ACK（n）确认到序列号n（包含n）的分组都已被正确接收</strong><br>可能收到重复ACK<br>为空中的分组设置计时器<br>超时时间：重传序列号大于等于n，还未收到ACK的所有分组</p>
<p><strong>接收方</strong><br>ACK机制：发送拥有最高序列号的，已被正确接收的分组的ACK<br>       可能产生重复ACK<br>       只需要记住唯一的expectedseqnum<br>乱序到达的分组<br>      直接丢弃-接收方没有缓存<br>      重新确认序列号最大的，按需到达的分组<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4qh22ds9oj30fe0fuaf2.jpg" alt="gbn"><br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4qh4o7f9fj30fe06atbf.jpg" alt="题目"></p>
<h4 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h4><p>接收方对每一个分组进行<strong>单独确认</strong><br>   设置<strong>缓存机制</strong>，缓存乱序到达的分组<br>发送方只重传那些没收到ACK的分组<br>   为每一个分组设置定时器<br>发送方窗口<br>   N个连续的序列号<br>   限制已发送且为确认的分组<br>   发送方尺寸+接收方尺寸&lt;=2K<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4qh6pqustj30fe0dd416.jpg" alt="SR"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4qh9wupssj30fe08rgp7.jpg" alt="流量控制"><br>当recwindow=0，选择发送一个很小的段，重新接收新的recwindow，避免死锁的情况</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>定义<br>太多发送主机发送了太多数据或者发送速度太快以至于网络无法处理</p>
<p>表现<br>分组丢失(路由器缓存溢出)<br>分组延迟过大(在路由器缓存中排队)</p>
<p>控制基本原理</p>
<p>sender限制发送速率<br>动态调整以改变发送速率<br>反映所感知到的拥塞控制</p>
<p>如何感知网络拥塞<br>Loss事件=timeout或3个重复ACK<br>发生loss事件后，发送方降低速率</p>
<p>如何合理的调整发送速率<br>加性增-乘性减：AIMD<br>慢启动：SS</p>
<p>加性增-乘性减<br>逐渐增加发送速率，谨慎探测可用带宽，直至发生loss<br>加性增：每个RTT将CongWin增大一个MSS-拥塞避免<br>乘性减：发生Loss后将CongWin减半</p>
<p>慢启动<br>TCP建立连接时<br>可用带宽可能远远高于初始速率<br>希望快速增长</p>
<p>原理<br>当连接开始时，指数性增长</p>
<p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4r34t3pl3j31h80nmdug.jpg" alt="变化"></p>
<p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4r3861b3bj31ha0n8wlr.jpg" alt="1"></p>
<p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4r3e0gqrzj31h80j5qn1.jpg" alt="2"></p>
<h3 id="流量控制与拥塞控制区别"><a href="#流量控制与拥塞控制区别" class="headerlink" title="流量控制与拥塞控制区别"></a>流量控制与拥塞控制区别</h3><p>流量控制：是一种端对端的，仅与特定的发送方和接收方有关</p>
<p>拥塞控制：确保子网可以承载所到达的流量，是一个全局性问题。</p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><h3 id="关于ip"><a href="#关于ip" class="headerlink" title="关于ip"></a>关于ip</h3><p>ipv4 32bit ipv6 128bit<br>子网掩码：不能单独存在，必须结合ip地址一起使用<br>作用，将某个ip地址划分为网络地址和主机地址两部分。<br>通过ip地址，可以判断出两个ip是不是在同一个局域网内部<br>子网掩码可以看出有多少位是网络号，有多少位是主机号</p>
<p><strong>ip地址与子网掩码做&amp;运算得到网络地址</strong></p>
<p>192.168.2.1/24<br>表示前24位不变，后8位全0变化到全1的过程<br>全0是子网网络地址，全1是子网广播地址，这两个地址是不分配给主机使用的。<br>表示范围 192.168.2.1-192.168.2.254</p>
<h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4rgkisl7tj31g30pedti.jpg" alt="格式"></p>
<p>TCP  6<br>UDP  17</p>
<h3 id="数据报分片"><a href="#数据报分片" class="headerlink" title="数据报分片"></a>数据报分片</h3><p>长度       标识          标记           偏移字段<br>4000               x              1               0<br>1500               x              1               0<br>1500               x              1               185<br>1040               x              0               370<br>（20个字节ip首部）</p>
<h3 id="直接交付与间接交付"><a href="#直接交付与间接交付" class="headerlink" title="直接交付与间接交付"></a>直接交付与间接交付</h3><p>直接交付：不经过路由器的报文传输</p>
<p>间接交付：需要路由器的转发交付</p>
<h3 id="分组的转发"><a href="#分组的转发" class="headerlink" title="分组的转发"></a>分组的转发</h3><p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4rgva0cjnj31gy0q7dw4.jpg" alt="分组"></p>
<p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4rhswugnpj30u00mi1d1.jpg" alt="题目"></p>
<p>目的网络地址H2 128.30.33.128</p>
<p>1.H1检查是否连在本网络上<br>本子网的子网掩码</p>
<h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h1><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><h3 id="链路状态路由选择算法"><a href="#链路状态路由选择算法" class="headerlink" title="链路状态路由选择算法"></a>链路状态路由选择算法</h3><p>Dijkstra算法<br>所有节点掌握网络拓扑和链路费用<br>通过链路状态广播<br>所有节点拥有相同信息<br>计算从一个节点到其他节点的最短路径</p>
<h3 id="距离向量路由选择算法"><a href="#距离向量路由选择算法" class="headerlink" title="距离向量路由选择算法"></a>距离向量路由选择算法</h3><p>Bellman-ford算法（动态规划）<br>dx(Y): 从x到y的最小距离<br>dx(Y)=min(c(x,v)+dv(Y))  不需要知道整个网络的拓扑结构<br><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4qhn0mjl0j30fe0a676u.jpg" alt="bellman-ford"><br>重点：节点获得最短路径的下一跳，该信息用于转发表中<br>结点x：<br>     已知到达每个邻居的费用：c(x,y)<br>     维护其所有邻居的距离向量Dv=【Dv（y）】<br>核心思想：<br>每个节点不定时的将其自身的DV估计发送给其邻居<br>当x接收到邻居新的DV估计时，及依据B-F更新其自身的距离向量</p>
<p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g4qhoh316zj30fe0av41y.jpg" alt="dv"></p>
<h4 id="毒性逆转"><a href="#毒性逆转" class="headerlink" title="毒性逆转"></a>毒性逆转</h4><p>思想 如果z通过y路由选择到目的地x，则z将通告y，到他到x的距离是无穷大。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="rip协议"><a href="#rip协议" class="headerlink" title="rip协议"></a>rip协议</h3><p>距离向量路由算法<br>距离度量：跳步数，每条链路一个跳步<br>每隔30s，邻居之间交换一次DV，成为公告<br>每次通告，最多25个目的子网</p>
<p>rip 链路失效，恢复<br>如果180s没有收到通告-邻居，链路失效<br>经过该邻居的路由不可用<br>   重新计算路由<br>向邻居发送新的通告<br>邻居在依次向外发送通告（如果转发表改变）</p>
<h3 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h3><p>“开放”：公众可用<br>采用链路状态路由算法<br>LS分组扩散<br>每个路由器构造完整的网络拓扑图<br>利用Dijkstra算法计算路由</p>
<p>OSPF通告中每个入口对应一个邻居</p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h2><h3 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h3><p>当节点有一个新帧要发送时，他等待下一个时隙开始并在该时隙传输整个帧<br>如果没有碰撞，该节点成功的传输他的帧，不需要考虑重传<br>如果有碰撞，该节点在时隙结束之前检测到这次碰撞，该节点已概率p在后续的每个时隙中重传他的帧，直到该帧被无碰撞的传输出去</p>
<h3 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h3><p>   非时隙，完全分散的协议<br>   当一帧首次到达，节点立刻将该帧完整的传输到广播信道，如果一个传输的帧与多个传输经历了碰撞，这个节点将立即已概率p重传该帧，否则，该节点等待一个帧传输时间。在此等待过后，他则以概率p传输该帧，否则以概率1-p在另一个帧时间等待。</p>
<h3 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h3><p>载波监听：<br>发送帧之前，监听信道（载波）<br>信道空闲：发送完整帧<br>信道忙：  推迟发送<br>1-    坚持CSMA<br>非坚持CSMA<br>P- 坚持CSMA</p>
<h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><p>短时间内检测冲突<br>冲突后传输中止，减少信道浪费<br>冲突检测：<br>有线局域网容易实现，测量信号强度，比较发射信号与接收信号<br>无线局域网很难实现，接收信号强度淹没在本地发射信号强度下<br>   边发边听，不发不听<br>当Lan中2个节点的最大传播延迟趋近于0或最长帧传输延迟趋近于∞时，效率趋近于1</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>接收入链路层帧并将他们转发到出链路</p>
<h3 id="交换机转发与过滤"><a href="#交换机转发与过滤" class="headerlink" title="交换机转发与过滤"></a>交换机转发与过滤</h3><p>过滤 决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能</p>
<p>转发 决定一个帧应当被转发到哪一个接口，并把该帧移动到那些接口的交换机功能</p>
<p>交换机的转发和过滤借助与交换机表</p>
<h2 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h2><p>交换机是自学习的</p>
<p>交换机表是通过自学习得到的</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>http   HyperText Transfer Protocol  超文本传输协议<br>      英特网上应用最为广泛的一种网络传输协议</p>
<p>Dns   Domain Name System   域名系统<br>      一个由分层的dns服务器实现的分布式数据库，一个使地主机能够查询分布式数据库的应用层协议</p>
<p>Smtp  Simple Mail Transfer Protocol    简单邮件传输协议<br>      一个相对简单的基于文本的协议 </p>
<p>ftp    File transfer protocol 文件传输协议<br>      用在网络上进行文件传输的一套标准协议</p>
<p>pop3  post office protocol-version 3   邮件协议版本3<br>      主要用于支持使用客户端远程管理在服务器上的电子邮件</p>
<p>Tcp   Transfer control protocol   传输控制协议<br>      面向连接的，可靠的，基于字节流的传输层通信协议</p>
<p>Rdt  reliable data transfer protocol  可靠数据传输协议<br>     为了保证数据传输的可靠性而在传输层采用的协议</p>
<p>Gbn  go-back N 回退N步<br>     允许发送方发送多个分组而不需等待确认，但也受限与流水线中未确认的分组数不能超过某个最大允许数N的一个协议</p>
<p>Sr    Selective Repeat   选择重传<br>      让发送方仅重传那些他怀疑在接收方出错的分组而避免了不必要的重传</p>
<p>icmp  Internet control message protocol   Internet控制报文协议<br>      用于在IP主机，路由器之间传递控制消息的协议</p>
<p>Rip   Routing Information protocol   路由信息协议<br>      是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递</p>
<p>Ospf  Open shortest Path First    开放式最短路径优先<br>      是一个内部网关协议，用于在单一自治系统内决定路由。</p>
<p>csma/cd   Carrier Sense Multiple Access/collision Detection 带碰撞检测的载波监听多路访问技术</p>
<h2 id="关于协议"><a href="#关于协议" class="headerlink" title="关于协议"></a>关于协议</h2><p>应用层<br>DNS FTP HTTP POP3 SMTP</p>
<p>传输层<br>TCP UDP</p>
<p>网络层<br>IP ICMP OSPF BGP IS </p>
<p>链路层<br>以太网</p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理复习</title>
    <url>/yzhiwei.github.io/2019/07/06/%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h1><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><p>吞吐量 一台计算机在某一时间间隔内能够处理的信息量</p>
<p>响应时间 从输入有效到系统产生响应之间的时间度量</p>
<p>利用率 在给定的时间间隔内系统被实际使用的时间所占的比率。用百分比来表示</p>
<p>处理机字长 指处理机运算器中一次能够完成二进制数运算的位数</p>
<p>总线宽度  cpu运算器与存储器之间进行互连的内部总线二进制位数</p>
<p>存储器容量 存储器中所有存储单元的总数目。通常用KB，MB表示</p>
<p>存储器带宽 单位时间内从存储器读出的二进制数信息量</p>
<p>主频/时钟周期 主时钟的频率教cpu的主频</p>
<p>cpu执行时间 表示CPU执行一般程序占用的CPU时间<br> CPU执行时间=CPU时钟周期数 CPU时钟周期</p>
<p>CPI 每条指令周期数</p>
<h2 id="硬件组成要素"><a href="#硬件组成要素" class="headerlink" title="硬件组成要素"></a>硬件组成要素</h2><p>运算器 进行算术运算和逻辑运算</p>
<p>控制器 控制计算机各部件有条不紊的工作</p>
<p>存储器 储存0，1代码</p>
<p>输入设备与输出设备</p>
<h2 id="多级组成的计算机系统"><a href="#多级组成的计算机系统" class="headerlink" title="多级组成的计算机系统"></a>多级组成的计算机系统</h2><p>微程序设计级   直接由硬件执行</p>
<p>一般机器级     微程序</p>
<p>操作系统级     操作系统</p>
<p>汇编语言级     汇编程序</p>
<p>高级语言级     编译程序</p>
<h1 id="运算方法和运算器"><a href="#运算方法和运算器" class="headerlink" title="运算方法和运算器"></a>运算方法和运算器</h1><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><h1 id="多层次的存储器"><a href="#多层次的存储器" class="headerlink" title="多层次的存储器"></a>多层次的存储器</h1><h2 id="存储器的分级"><a href="#存储器的分级" class="headerlink" title="存储器的分级"></a>存储器的分级</h2><p>Why  在一个存储器中同时兼顾容量大，速度快，成本低是困难的。</p>
<p>高速缓存存储器（cache） 高速存取指令和数据，存取速度快，但存储容量小</p>
<p>主存储器 存放计算机运行期间的大量程序和数据。和cache能交换数据和指令。</p>
<p>外存储器 大容量辅助存储器 存储容量大，位成本低，通常用来存放系统程序和大型数据文件及数据库</p>
<h2 id="主存储器的性能指标"><a href="#主存储器的性能指标" class="headerlink" title="主存储器的性能指标"></a>主存储器的性能指标</h2><p>字存储单元 存放一个机器字的存储单元。 相应的单元地址叫字地址。</p>
<p>字节存储单元 存放一个字节的单元 ，相应的地址为字节地址，</p>
<p>存储容量 一个存储器中可以容纳的存储单元总数。一个字节为8个2进制位</p>
<p>存储时间 存储器访问时间，指一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间。</p>
<p>存储周期 指连续启动两次读操作所需间隔的最小时间。</p>
<p>存储器带宽 单位时间内存储器所存取的信息量。</p>
<h2 id="存储器容量的扩充"><a href="#存储器容量的扩充" class="headerlink" title="存储器容量的扩充"></a>存储器容量的扩充</h2><p>1.字长位数扩展</p>
<p>2.字存储容量扩展</p>
<h2 id="多模块交叉存储器"><a href="#多模块交叉存储器" class="headerlink" title="多模块交叉存储器"></a>多模块交叉存储器</h2><p>地址在模块中安排方式有两种：顺序方式，交叉方式。</p>
<p>在顺序方式中，某个模块进行存取时，其他模块不工作。当某一模块出现故障时，其他模块可以照常工作。缺点就是各模块一个接一个串行工作，因此存储器的带宽受到了限制。</p>
<p>交叉方式的存储器可以实现多模块流水式并行存取，大大提高存储器的带宽</p>
<h2 id="cache基本原理"><a href="#cache基本原理" class="headerlink" title="cache基本原理"></a>cache基本原理</h2><p>解决cpu与主存之间速度不匹配</p>
<p>三个计算</p>
<p>1.命中率<br>h=Nc/(Nc+Nm)</p>
<p>2.平均访问时间<br>Ta=hTc+（1-h)Tm</p>
<p>3.访问效率<br>e=1/(r+(1-r)h)<br>r=Tm/Tc</p>
<h2 id="主存与cache的地址映射"><a href="#主存与cache的地址映射" class="headerlink" title="主存与cache的地址映射"></a>主存与cache的地址映射</h2><p><strong>主存块大小与cache行大小相同</strong></p>
<h3 id="直接映射方式"><a href="#直接映射方式" class="headerlink" title="直接映射方式"></a>直接映射方式</h3><p><img src="https://s2.ax1x.com/2019/07/08/ZrDyND.png" alt="直接"></p>
<p><strong>内存地址格式</strong> 标记 行 字地址</p>
<h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p><img src="https://s2.ax1x.com/2019/07/08/ZrsSsI.png" alt="全相联"></p>
<p><strong>内存地址格式</strong> 标记 字地址</p>
<h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p><img src="https://s2.ax1x.com/2019/07/08/Zrs6ld.png" alt="组相联"></p>
<p><strong>内存地址格式</strong> 标记 组号 字地址</p>
<h2 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h2><h3 id="最不经常使用（LFU）算法"><a href="#最不经常使用（LFU）算法" class="headerlink" title="最不经常使用（LFU）算法"></a>最不经常使用（LFU）算法</h3><p>设置计时器，从0开始技术，每访问一次，被访问的计数器增1，将一段时间内被访问次数最少的那行数据换出。</p>
<p>不能严格反映近期访问情况。</p>
<h3 id="近期最少使用（LRU）算法"><a href="#近期最少使用（LRU）算法" class="headerlink" title="近期最少使用（LRU）算法"></a>近期最少使用（LRU）算法</h3><p>将近期内长久未被访问的行换出</p>
<p>Cache每命中一次，命中行计数器清0，其他各行计数器增1，当需要替换时，将计数器最大的行换出。</p>
<p>使cache有较高的命中率</p>
<h3 id="随机替换"><a href="#随机替换" class="headerlink" title="随机替换"></a>随机替换</h3><p>从特定的行位置中随机的选取一行换出即可。</p>
<p>优点：在硬件上容易实现，且速度也比前两种快。</p>
<p>缺点：随意换出的数据很可能很快就被使用，从而降低命中率和cache工作效率</p>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>指令字用二进制代码表示的结构形式。由操作码字段和地址码字段组成。</p>
<p>操作码OP字段表征指令的操作特性与功能。<br>地址码A字段通常指定参与操作数的地址。</p>
<p>操作码<br>组成操作码字段的位数一般取决与计算机指令系统的规模。</p>
<p>地址码<br>根据一个指令中有几个操作数地址，可将该指令称为几操作数指令或几地址指令。</p>
<p>二地址指令格式中<br>存储器-存储器（SS）型指令 访问内存的指令格式。操作时都是涉及内存单元。<br>寄存器-寄存器（RR）型指令 访问寄存器的指令格式。<br>寄存器-存储器（RS）型指令 既要访问内存单元，又要访问寄存器。</p>
<p>指令字长度<br>一个指令字中包含二进制代码的位数。<br>分为单字长指令，半字长指令，双字长指令</p>
<p>分析指令格式的特点</p>
<ol>
<li>什么字长什么地址指令 （单字长二地址指令）</li>
<li>操作码字段op可以指定的指令数</li>
<li>分析指令</li>
</ol>
<h2 id="指令和数据的寻址方式"><a href="#指令和数据的寻址方式" class="headerlink" title="指令和数据的寻址方式"></a>指令和数据的寻址方式</h2><h3 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h3><h4 id="顺序寻址方式"><a href="#顺序寻址方式" class="headerlink" title="顺序寻址方式"></a>顺序寻址方式</h4><p>程序依次执行的过程</p>
<h4 id="跳跃寻址方式"><a href="#跳跃寻址方式" class="headerlink" title="跳跃寻址方式"></a>跳跃寻址方式</h4><p>当程序转移执行的顺序时，采用跳跃寻址方式。所谓跳跃，是指下条指令的地址码不是由程序计数器给出，而是由本条指令给出。</p>
<h3 id="操作数的寻址方式"><a href="#操作数的寻址方式" class="headerlink" title="操作数的寻址方式"></a>操作数的寻址方式</h3><p>形成操作数的有效方法，称为操作数的寻址方式<br>隐含寻址<br>不是明显的给出操作数的地址，而是在指令中隐含着操作数的地址</p>
<p>立即寻址<br>指令的地址阶段不是操作数的地址，而是操作数本身</p>
<p>直接寻址<br>在指令格式的地址字段中直接指出操作数在内存中的地址A</p>
<p>间接寻址<br>形式地址A不是操作数A的真正地址，而是操作数地址的指示器</p>
<p>寄存器寻址 当操作数不在内存中，而是放在cpu的通用寄存器中时，可采用寄存器寻址方式</p>
<p>寄存器间接寻址<br>指令格式中的寄存器内容不是操作数，而是操作数的地址</p>
<p>偏移寻址 直接寻址和寄存器间接寻址方式的结合<br>EA=A+（R）<br>相对寻址<br>基址寻址<br>变址寻址</p>
<p>段寻址方式</p>
<p>堆栈寻址<br>寄存器堆栈和存储器堆栈</p>
<h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><h2 id="cpu的功能"><a href="#cpu的功能" class="headerlink" title="cpu的功能"></a>cpu的功能</h2><p>指令控制 程序的顺序控制</p>
<p>操作控制 控制部件按指令的要求进行工作</p>
<p>时间控制 对各种操作实施时间上的定时</p>
<p>数据加工 对数据进行算术运算和逻辑运算处理</p>
<h2 id="cpu中的主要寄存器"><a href="#cpu中的主要寄存器" class="headerlink" title="cpu中的主要寄存器"></a>cpu中的主要寄存器</h2><p>数据缓冲寄存器（DR）<br>暂时存放ALU的运算结果</p>
<p>指令寄存器（IR）<br>用来保存当前正在执行的一条指令</p>
<p>程序计数器（PC）<br>确定下一条指令的地址</p>
<p>数据地址寄存器（AR）<br>保存当前cpu所访问的数据cache存储器中单元的地址</p>
<p>通用寄存器（R0-R3）<br>当算术逻辑单元（ALU）执行算术或逻辑运算时，为ALU提供一个工作区。</p>
<p>状态字寄存器（psw）<br>保存由算术指令和逻辑指令运算或测试结果建立的各种代码。</p>
<p>微程序控制器</p>
<p>优点<br>具有规整性，灵活性，可维护性等优点。</p>
<p>基本思想<br>仿照通常的解题程序的方法，把操作控制信号编成所谓的微指令，存放到一个只读存储器里，当机器运行时，一条又一条的读出这些微指令，从而产生全机所需要的各种操作控制信号，使相应部件执行所规定的动作。</p>
<p>微命令 控制部件通过控制线向执行部件发出各种控制命令。<br>微操作 执行部件接受微命令后所进行的操作</p>
<p>控制存储器 控制存储器用来存放全部指令系统的微程序，是一种只读型存储器。</p>
<p>微指令寄存器<br>存放由控制存储器读出的一条微指令信息。<br>决定将要访问的下一条微指令的地址</p>
<h2 id="流水CPU"><a href="#流水CPU" class="headerlink" title="流水CPU"></a>流水CPU</h2><h3 id="并行处理技术"><a href="#并行处理技术" class="headerlink" title="并行处理技术"></a>并行处理技术</h3><p>时间并行<br>空间并行<br>时间并行+空间并行</p>
<h3 id="流水线的结构"><a href="#流水线的结构" class="headerlink" title="流水线的结构"></a>流水线的结构</h3><h4 id="时空图"><a href="#时空图" class="headerlink" title="时空图"></a>时空图</h4><p>非流水线时空图<br>流水线时空图</p>
<h4 id="流水线分类"><a href="#流水线分类" class="headerlink" title="流水线分类"></a>流水线分类</h4><p>指令流水线<br>算数流水线<br>处理机流水线  宏流水线，是指程序步骤的并行。</p>
<h3 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h3><h4 id="资源相关"><a href="#资源相关" class="headerlink" title="资源相关"></a>资源相关</h4><p>多条指令进入流水线后在同一机器时钟周期内争用同一个功能部件所发生的冲突</p>
<h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><p>先写后读（RAW）<br>对应真数据相关时的情况，下一条指令依赖于上一条指令的执行结果，<strong>必须先将结果写入之后再由下一条指令来读</strong>。如果先读的话读到的是旧值，不是运算的正确输入。</p>
<p>先写后写（WAW）<br>这个对应于<strong>输出</strong>相关，比如最后将要输出的值为后一条指令的执行结果，可是这条指令却先执行并写入了，之后执行了上一条指令的写入操作，对应于输出的结果而言就出现冲突了。</p>
<p>先读后写（WAR）<br>这个对应于名相关，指令在读取某一数据之前其读取的对象先被相关的指令写入了运算结果，这导致了读取的数据不是原来的数据，而是下一条指令运行的结果</p>
<h4 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h4><p>延迟转移法<br>转移预测法</p>
<h1 id="总线系统"><a href="#总线系统" class="headerlink" title="总线系统"></a>总线系统</h1><h2 id="总线的概念"><a href="#总线的概念" class="headerlink" title="总线的概念"></a>总线的概念</h2><p>构成计算机系统的互联结构，是多个系统功能部件进行数据传送的公共同路，借助与总线连接，计算机在个系统功能部件之间实现地址，数据和控制信息的交换，并在征用资源的基础上进行工作。</p>
<p>总线分为3类<br>内部总线<br>cpu内部连接各寄存器及运算部件之间的总线。</p>
<p>系统总线  cpu同计算机系统的其他高速功能部件，如存储器，通道等相互连接的总线。</p>
<p>I/O总线<br>低速I/O设备之间相互连接的总线。</p>
<h2 id="总线接口"><a href="#总线接口" class="headerlink" title="总线接口"></a>总线接口</h2><p>信息传送方式<br>串行传送 按顺序来传送表示一个数码的所有二进制位的脉冲信号，每次一位。<br>并行传送 对每个数据位都需要单独一条传输线。信息有多少二进制位组成，就需要多少传输线，从而使得二进制位数在不同的线上同时进行传输。<br>分时传送。<br>1 总线复用方式 某个传输线上既传送地址信息，又传送数据信息。<br>2 共享总线的部分分时使用总线。</p>
<p>接口模块的功能<br>控制<br>靠指令信息来控制外围设备的动作</p>
<p>缓冲<br>在外围设备和计算机系统其他部件之间用作一个缓冲器，以补偿各种设备在速度上的差异。 </p>
<p>状态<br>监视外围设备的工作状态并保存状态信息</p>
<p>转换<br>可以完成任何要求的数据转换</p>
<p>整理<br>可以完成一些特别的功能，在需要时修改字计数器或当前内存地址寄存器</p>
<p>程序中断<br>每当外围设备向cpu请求某种动作时，接口模块即发生一个中断请求信号到cpu</p>
<h2 id="总线的总裁"><a href="#总线的总裁" class="headerlink" title="总线的总裁"></a>总线的总裁</h2><p>为了解决多个主设备同时竞争总线控制权的问题，必须具有总线仲裁部件。<br>一般采用优先级或公平策略进行仲裁。</p>
<h3 id="集中式仲裁"><a href="#集中式仲裁" class="headerlink" title="集中式仲裁"></a>集中式仲裁</h3><p>每个功能模块有两条线连到总线控制器：一条是送往仲裁器的总线请求信号线BR，一条是仲裁器送出的总线授权信号线BG</p>
<h4 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h4><p>总线授权信号BG串行的从一个I/O接口传送到下一个I/O接口。假如BG到达的接口无总线请求，则继续向下查询，假如BG到达的接口有总线请求，BG信号便不再向下查询。</p>
<p>特点 在查询链中离总线仲裁器最近的设备具有最高优先级。</p>
<p>优点： 只用很少几根线就能按一定优先次序实现总线仲裁，并且这种链式结构很容易扩充设备</p>
<p>缺点  对询问链的电路很敏感，如果第i个设备的接口中有关链的电路有故障，那么第i个以后的设备都不能正常工作。查询链的优先级是固定的，如果优先级高的设备出现频繁的请求时，那么优先级低的设备将长期不能使用总线。</p>
<h4 id="计时器定时查询方式"><a href="#计时器定时查询方式" class="headerlink" title="计时器定时查询方式"></a>计时器定时查询方式</h4><p>总线上任一设备要求使用总线时，通过BR线发出总线请求，总线仲裁器在接收到信号以后，在BS线为0的情况下让计数器开始计数，计数值通过一组地址线发现该设备。每个设备接口都有一个设备地址判别电路，当地址线上的计数值与请求总线的设备地址相一致时，该设备置1BS线，获得了总线使用权，此时中止计数查询</p>
<p>优点  可以由计数器的初值方便的改变优先次序。</p>
<h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><p>每一个共享总线的设备<strong>均有一对总线请求线BR和总线授权线BG</strong>，当设备要求使用总线时，便发出该设备的总线信号。总线仲裁器有一个排队电路，根据一定的优先次序决定优先相应哪一个设备，给设备已授权信号BG</p>
<p>优点：相应速度快，对优先次序的控制相当灵活。他可以预先固定优先级，也可以通过程序来改变优先次序，还可以用屏蔽某个请求的方法，不响应来自无效设备的请求。</p>
<h3 id="分布式仲裁"><a href="#分布式仲裁" class="headerlink" title="分布式仲裁"></a>分布式仲裁</h3><p>不需要集中的总线仲裁器，每个潜在的主方功能模块都有自己的仲裁号和仲裁器。当他们有总线请求时，把他们唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将仲裁总线上的号与自己做比较，如果仲裁总线上的号大，则他的总线请求不予响应，并撤销他的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。<br>分布式仲裁是以优先级仲裁策略为基础。</p>
<h1 id="外存与IO设备"><a href="#外存与IO设备" class="headerlink" title="外存与IO设备"></a>外存与IO设备</h1><h2 id="磁盘存储设备"><a href="#磁盘存储设备" class="headerlink" title="磁盘存储设备"></a>磁盘存储设备</h2><h3 id="磁盘上信息的分布"><a href="#磁盘上信息的分布" class="headerlink" title="磁盘上信息的分布"></a>磁盘上信息的分布</h3><p>盘面的上下两面都能记录信息，通常把磁盘片表面称为记录面。记录面上一系列同心圆称为磁道</p>
<p>磁道和扇区的排列称为格式。</p>
<p>编号：磁道的编址是从外向内依次编号，最外一个同心圆叫0磁道，最里面的一个同心圆叫n磁道，n磁道里面的圆面积并不用来记录信息。</p>
<p>扇区的编号有多种方法，可以连续编号，也可以间隔编号。</p>
<p>可用n磁道m扇区的磁盘地址找到实际磁盘上与之相对应的记录区。</p>
<p>对活动头磁盘组来说，<strong>磁盘地址是由记录面号（磁头号），磁道号和扇区号三部分组成。</strong></p>
<p>在磁道中，信息是按区存放的，每个区中存放一定数量的字或字节，每个区存放字或字节数是相同的。</p>
<p>磁盘存储器的每个扇区记录定长的数据，因此读/写操作是以扇区为单位一位一位串行进行的。</p>
<p>每个记录块由头部空白段，序标段，数据段，校验字段以及尾部空白段组成。<br>空白段用来留出一定时间作为磁盘控制器的读写准备时间，序标被用来作为磁盘控制器的同步定时信号。数据段为本扇区所记录的数据。校验字段用来检验磁盘读出的数据是否正确。</p>
<h3 id="磁盘存储器的技术指标"><a href="#磁盘存储器的技术指标" class="headerlink" title="磁盘存储器的技术指标"></a>磁盘存储器的技术指标</h3><p>存储密度：存储密度分为道密度，位密度和面密度。<br>道密度：沿磁盘半径方向单位长度的磁道数：   单位：道/英寸<br>位密度  磁道单位长度上能记录的二进制位数   单位  位/英寸<br>面密度  道密度和位密度的乘积</p>
<p>存储容量 一个磁盘存储器所能存储的字节总数，称为磁盘存储器的存储容量。<br>分为格式化容量和非格式化容量，<br>格式化容量：按照某种特定的记录格式所能存储的信息总量，是用户可以真正使用的容量。<br>非格式化容量：磁记录表面可以利用的磁化单元总数。</p>
<p>平均存取时间 是指从发出读写命令后，磁头从某一起始位置移动到新的记录位置，到开始从磁盘表面读出或写入信息加上传送数据所需要的时间。</p>
<p>1.将磁头定位到所要求的磁道上所需要的时间称为找道时间 （最大找道时间与最小找道时间的平均值，目前平均找道时间为12ms）<br>2.找道完成后至磁道上需要访问的信息到达磁头上的时间称为等待时间 （磁盘旋转一周所需时间的一半）<br>3.数据传送时间</p>
<p>计算</p>
<p>平均存取时间<br>Ta=Ts（找道时间）+1/2<em>r（等待时间）+b/r</em>n（数据传送时间）<br>r 转速<br>b 传送的字节数</p>
<p>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数。<br>Dr=nN(字节/秒)<br>n 磁盘旋转速度<br>N 每磁道字节数</p>
<h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统　　"></a>输入输出系统　　</h1><h2 id="外围设备的速度分级与信息交换方式"><a href="#外围设备的速度分级与信息交换方式" class="headerlink" title="外围设备的速度分级与信息交换方式"></a>外围设备的速度分级与信息交换方式</h2><h3 id="外围设备的速度分级"><a href="#外围设备的速度分级" class="headerlink" title="外围设备的速度分级"></a>外围设备的速度分级</h3><p>速度极慢或简单的外围设备<br>如机械开关，显示二极管等。Cpu只要接收或发送数据就可以了。</p>
<p>慢速或中速的外围设备<br>异步定时方式</p>
<p>高速的外围设备<br>同步定时方式</p>
<h3 id="信息交换方式"><a href="#信息交换方式" class="headerlink" title="信息交换方式"></a>信息交换方式</h3><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>最简单的输入输出方式，数据在cpu和外围设备之间传送完全靠计算机程序控制</p>
<p>优点：cpu的操作与外围设备的操作能够同步，硬件结构比较简单。<br>缺点：外围设备动作很慢，程序进入查询循环时将白白浪费掉cpu很多时间。</p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p>中断是外围设备主动告诉cpu，准备送出输入数据或接收输出数据的一种方法。<br>当一个中断发生后，cpu暂停他的现行程序，而转向中断处理程序，从而可以输入或输出一个数据。</p>
<p>优点：节约了cpu的时间，是管理I/O操作的一个比较有有效的操作方法。</p>
<h4 id="直接内存访问模式-DMA"><a href="#直接内存访问模式-DMA" class="headerlink" title="直接内存访问模式(DMA)"></a>直接内存访问模式(DMA)</h4><p>由硬件执行I/O交换的工作方式。这种方式及考虑到中断响应，同时又要节约中断开销。<br>DMA控制器从cpu完全接管对总线的控制，数据交换完全不经过cpu，而直接在内存和外围设备之间进行。</p>
<p>优点：数据传送速度很高，传送速率仅受到内存访问时间的限制。<br>缺点：与中断方式相比，需要更多的硬件。</p>
<p>使用场合：内存与高速外围设备之间大批数据交换的场合。</p>
<h4 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h4><p>Cpu将部分权力下放给通道，通道是一个具有特殊功能的处理器。可以实现对外围设备的统一管理和外围设备与内存之间的数据传送。</p>
<p>优点：大大提高效率<br>缺点：花费更多硬件为代价</p>
<p>主要由程序实现：程序查询方式，查询中断方式<br>主要由硬件实现：DMA，通道</p>
<h2 id="程序中断方式-1"><a href="#程序中断方式-1" class="headerlink" title="程序中断方式"></a>程序中断方式</h2><h3 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h3><p>在程序中断方式中，某一外设的数据准备就绪后，它主动向cpu发送信号，请求cpu暂时中断目前正在执行的程序而进行数据交换。</p>
<h3 id="多级中断"><a href="#多级中断" class="headerlink" title="多级中断"></a>多级中断</h3><p>多级中断系统是指计算机系统中有相当多的中断源，根据各中断事件的轻重缓急程度不同而分成若干级别，每一中断级分配给一个优先权。</p>
<p><strong>一般在某一级中断被响应后，要置“1”（关闭）本级和优先权低于本级的中断屏蔽发生器，置“0”（开放）更高级的中断屏蔽触发器，以此来实现正常的中断嵌套。</strong><br>具体题参考例2</p>
<h3 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h3><p>中断优先级选择方式</p>
<p>完全嵌套方式<br>一种固定优先级的方式，连至IR0的设备优先级最高，IR7优先级最低</p>
<p>轮换优先级方式A<br>每个级别的中断保证都能够被处理，将给定的中断级别处理完后，立刻将它放在最低级别的位置中。</p>
<p>轮换优先级方式B<br>要求CPU可在任何时间规定最优优先级，然后顺序的规定其他IR线上的优先级。</p>
<p>查询方式<br>由cpu访问8259的中断状态寄存器，一个状态字能够表示出正在请求的最高优先级IR线。</p>
<p>两种屏蔽方式</p>
<p>简单屏蔽方式<br>提供8位屏蔽字，每位对应着各自的IR线。被置位的任一位则禁止了对应IR线上的中断。</p>
<p>特殊屏蔽方式<br>允许cpu让来自低优先级的外设中断请求去中断高优先级的服务程序。</p>
<h2 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h2><p>是一种完全由硬件执行I/O交换的工作方式。</p>
<p>DMA控制器从cpu完全接管对总线的控制。</p>
<p>优点：速度快</p>
<h3 id="DMA传送方式"><a href="#DMA传送方式" class="headerlink" title="DMA传送方式"></a>DMA传送方式</h3><p>停止CPU访内<br>周期挪用<br>DMA与cpu交替访内</p>
]]></content>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫问题（dfs）</title>
    <url>/yzhiwei.github.io/2019/02/27/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%EF%BC%88dfs%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\yzhiwei.github.io\assets\css\APlayer.min.css"><script src="\yzhiwei.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h1><p>给定迷宫中起点和终点，以及可以走的格子及不能走的格子，输出任意一条路径。</p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p> T…<em>.<br> …</em>..<br> **…S</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p> mmm.<em>.<br> ..m</em>..<br> **mmmS</p>
<h1 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">string</span> maze[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100</span>][<span class="number">100</span>];  <span class="comment">//判断是否走过</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m;</span><br><span class="line">&#125; <span class="comment">//判断是否出界</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;  <span class="comment">//四个方向搜索</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(maze[x][y]==<span class="string">'S'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    vis[x][y]=<span class="number">1</span>;  </span><br><span class="line">    maze[x][y]=<span class="string">'m'</span>;</span><br><span class="line">    <span class="keyword">int</span> tx,ty;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tx=x+a[i][<span class="number">0</span>];</span><br><span class="line">        ty=y+a[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(in(tx,ty)&amp;&amp;maze[tx][ty]!=<span class="string">'*'</span>&amp;&amp;!vis[tx][ty])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(tx,ty))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x][y]=<span class="number">0</span>;</span><br><span class="line">    maze[x][y]=<span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;maze[i];</span><br><span class="line">   <span class="keyword">int</span> x,y;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maze[i][j]==<span class="string">'T'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x=i;</span><br><span class="line">            y=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(dfs(x,y))&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
</search>
